# Glide生命周期绑定分析

## 方法调用链
1. `Glide.with(Activity)`
2. `RequestManagerRetriever.get(Activity)`
3. `fragmentGet(Context, FragmentManager, parentHint)`
    - `getRequestManagerFragment(FragmentManager, parentHint)` → 添加无界面Fragment，绑定生命周期
    - `factory.build(glide, lifecycle, treeNode)` → 构建 `RequestManager`

关键代码（节选）：

```java
private RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
      android.app.Fragment parentHint) {
    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);
    RequestManager requestManager = current.getRequestManager();
    if (requestManager == null) {
      // TODO(b/27524013): Factor out this Glide.get() call.
      Glide glide = Glide.get(context);
      requestManager =
          factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());
      current.setRequestManager(requestManager);
    }
    return requestManager;
  }
```

```java
RequestManagerFragment getRequestManagerFragment(
      final android.app.FragmentManager fm, android.app.Fragment parentHint) {
    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
    if (current == null) {
      current = pendingRequestManagerFragments.get(fm);
      if (current == null) {
        current = new RequestManagerFragment();
        current.setParentFragmentHint(parentHint);
        pendingRequestManagerFragments.put(fm, current);
        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
        handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
      }
    }
    return current;
  }
```

## 生命周期绑定过程分析

- 隐藏 Fragment 绑定到页面：
    - 作为 `FragmentManager` 的子 Fragment，天然接收 `onStart/onStop/onDestroy` 回调。
- Fragment → Lifecycle 分发：
    - `RequestManagerFragment` 内部持有 `ActivityFragmentLifecycle`。
    - 在其 `onStart/onStop/onDestroy` 中调用 `lifecycle.onStart()/onStop()/onDestroy()`。
- `RequestManager` 监听 Lifecycle：
    - 构造时将自己注册为 `LifecycleListener`。
    - 在回调中执行 `resumeRequests()/pauseRequests()/clear()`，从而与页面生命周期联动。
- 层级递归：
    - 通过 `RequestManagerTreeNode` 获取子层级的 `RequestManager`，支持 `pause/resume` 递归传播。
- 与 `with(Context)` 的区别：
    - 应用级 `RequestManager` 使用 `ApplicationLifecycle`，不跟随页面生命周期，仅适用于服务、通知等场景。

## 问题整理

### 1）getRequestManagerFragment方法最后为什么要移除当前页面的FragmentManager

- 临时占位与并发幂等：
    - `commitAllowingStateLoss()` 异步提交期间，后续对同一 `FragmentManager` 的再次请求会命中临时表，统一返回同一 `RequestManagerFragment`，避免重复 `add`。
- 提交完成后的清理：
    - 事务一旦生效，后续应走 `findFragmentByTag()` 的稳定路径；临时强引用没有必要，及时移除可降低泄漏风险。
- 关键路径（节选）：

```java
// 添加并安排清理
pendingRequestManagerFragments.put(fm, current);
fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();

// 下一轮消息中移除
case ID_REMOVE_FRAGMENT_MANAGER:
    removed = pendingRequestManagerFragments.remove(fm);
    break;
```

### 2）为何能确保移除前事务已处理完

- 同一主线程 Looper 顺序执行：
    - `commitAllowingStateLoss()` 提交的事务与 `handler.sendToTarget()` 的清理消息都派发到主线程；
    - 代码顺序为“先提交事务、再发清理消息”，主线程按队列处理，通常会先应用该次事务，再处理清理消息；
    - 因此清理时 `findFragmentByTag(FRAGMENT_TAG)` 已能命中真正的 Fragment，后续路径稳定。
- 兼容与容错：
    - 极端时序下仍有双路径保护（`findFragmentByTag()` 与 pending Map）与日志告警，确保功能一致性。
