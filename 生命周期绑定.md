# Glide生命周期绑定分析

## 方法调用链

### 4.0版本
1. `Glide.with(Activity)`
2. `RequestManagerRetriever.get(Activity)`
3. `fragmentGet(Context, FragmentManager, parentHint)`
  - `getRequestManagerFragment(FragmentManager, parentHint)` → 添加无界面Fragment，绑定生命周期
  - `factory.build(glide, lifecycle, treeNode)` → 构建 `RequestManager`

关键代码（节选）：

```java
private RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
                                   android.app.Fragment parentHint) {
  RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);
  RequestManager requestManager = current.getRequestManager();
  if (requestManager == null) {
    // TODO(b/27524013): Factor out this Glide.get() call.
    Glide glide = Glide.get(context);
    requestManager =
            factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());
    current.setRequestManager(requestManager);
  }
  return requestManager;
}
```

```java
RequestManagerFragment getRequestManagerFragment(
        final android.app.FragmentManager fm, android.app.Fragment parentHint) {
  RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
  if (current == null) {
    current = pendingRequestManagerFragments.get(fm);
    if (current == null) {
      current = new RequestManagerFragment();
      current.setParentFragmentHint(parentHint);
      pendingRequestManagerFragments.put(fm, current);
      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
      handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
    }
  }
  return current;
}
```

### 4.1x版本
1. `Glide.with(FragmentActivity)` / `Glide.with(Fragment)`
2. `RequestManagerRetriever.get(FragmentActivity)` / `get(Fragment)`
  - 直接使用 AndroidX 的 `Lifecycle`：`activity.getLifecycle()` / `fragment.getLifecycle()`
  - `lifecycleRequestManagerRetriever.getOrCreate(...)` → 构建并绑定 `RequestManager`

关键代码（节选）：

```java
// RequestManagerRetriever.get(FragmentActivity)
public RequestManager get(@NonNull FragmentActivity activity) {
    if (Util.isOnBackgroundThread()) {
      return get(activity.getApplicationContext());
    }
    assertNotDestroyed(activity);
    frameWaiter.registerSelf(activity);
    boolean isActivityVisible = isActivityVisible(activity);
    Glide glide = Glide.get(activity.getApplicationContext());
    return lifecycleRequestManagerRetriever.getOrCreate(
        activity,
        glide,
        activity.getLifecycle(),
        activity.getSupportFragmentManager(),
        isActivityVisible);
  }
```

## 生命周期绑定过程分析

### 4.0版本
- 无界面 Fragment 绑定到页面：
  - 作为 `FragmentManager` 的子 Fragment，天然接收 `onStart/onStop/onDestroy` 回调。
- Fragment → Lifecycle 分发：
  - `RequestManagerFragment` 内部持有 `ActivityFragmentLifecycle`。
  - 在其 `onStart/onStop/onDestroy` 中调用 `lifecycle.onStart()/onStop()/onDestroy()`。
- `RequestManager` 监听 Lifecycle：
  - 构造时将自己注册为 `LifecycleListener`。
  - 在回调中执行 `resumeRequests()/pauseRequests()/clear()`，从而与页面生命周期联动。
- 层级递归：
  - 通过 `RequestManagerTreeNode` 获取子层级的 `RequestManager`，支持 `pause/resume` 递归传播。
- 与 `with(Context)` 的区别：
  - 应用级 `RequestManager` 使用 `ApplicationLifecycle`，不跟随页面生命周期，仅适用于服务、通知等场景。

### 4.1x版本

- 生命周期来源：
  - 直接使用 AndroidX 的 `Lifecycle`（`FragmentActivity.getLifecycle()` / `Fragment.getLifecycle()`）作为绑定源。
- 统一桥接与构建：
  - 通过 `lifecycleRequestManagerRetriever.getOrCreate(...)` 将 `Lifecycle`、`FragmentManager`、可见性等信息桥接给 Glide，构建并返回与页面生命周期绑定的 `RequestManager`。
- RequestManager 注册与回调：
  - 构造时注册到 `Lifecycle`，在主线程或通过切到主线程后完成注册。
- 层级传播：
  - 通过 `RequestManagerTreeNode` 获取子层级 `RequestManager`，`pauseRequestsRecursive()/resumeRequestsRecursive()` 将状态在页面层级内递归传播。
- 注意点：
  - `with(Context)` 与（已弃用的）`with(Activity)` 走应用级 `ApplicationLifecycle`，不会随页面生命周期自动暂停/恢复；需手动控制或改用 `FragmentActivity/Fragment` 重载。
  - `with(View)` 优先尝试定位所处 Fragment（仅 AndroidX），找不到则回退为应用级。

## 问题整理

### 4.0版本
#### 1）getRequestManagerFragment方法最后为什么要移除当前页面的FragmentManager

- 临时占位与并发幂等：
  - `commitAllowingStateLoss()` 异步提交期间，后续对同一 `FragmentManager` 的再次请求会命中临时表，统一返回同一 `RequestManagerFragment`，避免重复 `add`。
- 提交完成后的清理：
  - 事务一旦生效，后续应走 `findFragmentByTag()` 的稳定路径；临时强引用没有必要，及时移除可降低泄漏风险。
- 关键路径（节选）：

```java
// 添加并安排清理
pendingRequestManagerFragments.put(fm, current);
fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();

// 下一轮消息中移除
case ID_REMOVE_FRAGMENT_MANAGER:
    removed = pendingRequestManagerFragments.remove(fm);
    break;
```

#### 2）为何能确保移除前事务已处理完

- 同一主线程 Looper 顺序执行：
  - `commitAllowingStateLoss()` 提交的事务与 `handler.sendToTarget()` 的清理消息都派发到主线程；
  - 代码顺序为“先提交事务、再发清理消息”，主线程按队列处理，通常会先应用该次事务，再处理清理消息；
  - 因此清理时 `findFragmentByTag(FRAGMENT_TAG)` 已能命中真正的 Fragment，后续路径稳定。
- 兼容与容错：
  - 极端时序下仍有双路径保护（`findFragmentByTag()` 与 pending Map）与日志告警，确保功能一致性。


## 版本对比

### 升级后的生命周期绑定优化点
- 以 AndroidX Lifecycle 为核心绑定：
  - 直接注入 `Lifecycle`，无需无界面 Fragment，避免事务时序、状态丢失问题。
- 移除无界面 Fragment：
  - 不再依赖 `commitAllowingStateLoss()`/pending Map/Handler 清理，减少强引用与泄漏风险，降低日志噪音与边界异常。
- 运行时开销更低、确定性更强：
  - 无额外 Fragment 事务，生命周期回调单一来源，行为更一致。
- API 指引更清晰：
  - 弃用 `with(Activity)`（退化为应用级，不随页面生命周期），推荐 `with(FragmentActivity)` / `with(Fragment)`。
- 启动阶段稳健性提升：
  - 引入首帧等待（`FrameWaiter`）配合硬件位图策略，降低初始化阶段潜在问题（虽非直接绑定，但整体稳定性更好）。
- 增强对嵌套Fragment的支持：
  - 子 Fragment 使用 Glide.with(fragment) 时，Glide 会更精准地绑定到子 Fragment 的生命周期，而非直接关联到宿主 Activity 或父 Fragment
